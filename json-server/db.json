{
  "posts": [
    {
      "id": "1",
      "title": "json-server",
      "userId": "1"
    },
    {
      "id": "2",
      "title": "json-server",
      "userId": "2"
    }
  ],
  "articles": [
    {
      "id": "1",
      "title": "JavaScript new",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 1012,
      "created": "25.02.2024",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "2",
      "title": "2JavaScript new",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 1012,
      "created": "25.02.2024",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    }
  ],
  "comments": [
    {
      "id": "1",
      "text": "some comment",
      "articleId": "1",
      "userId": "2"
    },
    {
      "id": "2",
      "text": "some comment 2",
      "articleId": "1",
      "userId": "2"
    },
    {
      "id": "1",
      "text": "some comment 3",
      "articleId": "1",
      "userId": "2"
    },
    {
      "id": "2",
      "text": "some comment 4",
      "articleId": "1",
      "userId": "2"
    }
  ],
  "users": [
    {
      "id": "1",
      "username": "admin",
      "password": "123",
      "role": "ADMIN",
      "avatar": "https://i0.wp.com/securitymadesimple.org/wp-content/uploads/2023/03/a19aa-computerhacker.png?fit=1280%2C960&ssl=1"
    },
    {
      "id": "2",
      "username": "admin",
      "password": "1234",
      "role": "USER",
      "avatar": "https://i0.wp.com/securitymadesimple.org/wp-content/uploads/2023/03/a19aa-computerhacker.png?fit=1280%2C960&ssl=1"
    }
  ],
  "profile": {
    "name": "typicode",
    "first": "sdfsIgor",
    "lastname": "Danilovsdfsd",
    "age": "30",
    "country": "USA",
    "city": "California",
    "currency": "EUR",
    "avatar": "https://i0.wp.com/securitymadesimple.org/wp-content/uploads/2023/03/a19aa-computerhacker.png?fit=1280%2C960&ssl=1"
  }
}
