{
  "posts": [
    {
      "id": "1",
      "title": "json-server",
      "userId": "1"
    },
    {
      "id": "2",
      "title": "json-server",
      "userId": "2"
    }
  ],
  "articles": [
    {
      "id": "1",
      "title": "JavaScript new",
      "userId": "1",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 1,
      "created": "01.02.2024",
      "type": [
        "ECONOMICS"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "2",
      "title": "JavaScript new",
      "userId": "2",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 109,
      "created": "02.02.2024",
      "type": [
        "SCIENCE"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "3",
      "title": "JavaScript new",
      "userId": "1",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 12,
      "created": "03.02.2024",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "4",
      "title": "JavaScript new",
      "userId": "2",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 145,
      "created": "04.02.2024",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "5",
      "title": "JavaScript new",
      "userId": "1",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 903,
      "created": "05.02.2024",
      "type": [
        "MOVIES"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "6",
      "title": "JavaScript new",
      "userId": "2",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 578,
      "created": "06.02.2024",
      "type": [
        "TECH"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "7",
      "title": "JavaScript new",
      "userId": "1",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 893,
      "created": "06.02.2024",
      "type": [
        "SCIENCE"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "8",
      "title": "JavaScript new",
      "userId": "2",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 1012,
      "created": "19.02.2024",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "9",
      "title": "JavaScript new",
      "userId": "1",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 435,
      "created": "13.02.2024",
      "type": [
        "ECONOMICS"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    },
    {
      "id": "10",
      "title": "JavaScript new",
      "userId": "2",
      "subtitle": "Что нового в JS",
      "img": "https://static.javatpoint.com/images/javascript/javascript_logo.png",
      "views": 353,
      "created": "12.02.2024",
      "type": [
        "MOVIES"
      ],
      "blocks": [
        {
          "id": "1",
          "title": "Заголовок этого блока",
          "type": "TEXT",
          "paragraphs": [
            "Когда мы сталкиваемся с длительными операциями, такими как сетевые запросы или транзакции в базу данных, то надо быть уверенным, что запуск происходит в фоновом потоке. Если же забыть об этом, то можно получить блокировку UI потока еще до того, как задача закончится. А во время блокировки UI пользователь не сможет взаимодействовать с приложением.\n\n\nК сожалению, когда мы запускаем задачу в фоне, то не можем использовать результат тут же. Для этого нам потребуется некая разновидность callback'а. Когда callback будет вызван с результатом, только тогда мы сможем продолжить, например запустить еще один сетевой запрос.\n\n\nПростой пример того, как люди приходят к \"callback hell\": несколько вложенных callback'ов, все ждут вызова когда долгоиграющая операция закончится."
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "fun retrieveIssues() {\n    githubApi.retrieveUser() { user ->\n        githubApi.repositoriesFor(user) { repositories ->\n            githubApi.issueFor(repositories.first()) { issues ->\n                handler.post { \n                    textView.text = \"You have issues!\" \n                }\n            }\n        }\n    }\n}"
        },
        {
          "id": "3",
          "title": "Заголовок этого блока",
          "type": "IMAGE",
          "src": "https://static.javatpoint.com/images/javascript/javascript_logo.png"
        }
      ]
    }
  ],
  "comments": [
    {
      "id": "1",
      "text": "some comment",
      "articleId": "1",
      "userId": "2"
    },
    {
      "id": "2",
      "text": "some comment 2",
      "articleId": "1",
      "userId": "2"
    },
    {
      "id": "1",
      "text": "some comment 3",
      "articleId": "2",
      "userId": "2"
    },
    {
      "id": "2",
      "text": "some comment 4",
      "articleId": "2",
      "userId": "2"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "new comment",
      "id": "hpNJo6W"
    },
    {
      "articleId": "2",
      "userId": "1",
      "text": "new comment2",
      "id": "wzg_nY5"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "1231",
      "id": "4YIOlb7"
    },
    {
      "articleId": "2",
      "userId": "1",
      "text": "141",
      "id": "dJto3ed"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "11111111",
      "id": "DY0JoRX"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "sdsD",
      "id": "g1sVGr6"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "adasda",
      "id": "Ahu7ooY"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "356353",
      "id": "6t9J0UA"
    }
  ],
  "users": [
    {
      "id": "1",
      "username": "admin",
      "password": "123",
      "role": "ADMIN",
      "avatar": "https://i0.wp.com/securitymadesimple.org/wp-content/uploads/2023/03/a19aa-computerhacker.png?fit=1280%2C960&ssl=1"
    },
    {
      "id": "2",
      "username": "admin",
      "password": "1234",
      "role": "USER",
      "avatar": "https://www.soscanhelp.com/hs-fs/hubfs/Dark%20Web%20Hacker%20Blue%20Glow.jpeg?width=3008&name=Dark%20Web%20Hacker%20Blue%20Glow.jpeg"
    }
  ],
  "profile": [
    {
      "name": "first user",
      "id": "1",
      "first": "1Igor",
      "lastname": "Danilovsdfsd",
      "age": "30",
      "country": "Russia",
      "city": "Moscow",
      "currency": "EUR",
      "avatar": "https://i0.wp.com/securitymadesimple.org/wp-content/uploads/2023/03/a19aa-computerhacker.png?fit=1280%2C960&ssl=1"
    },
    {
      "name": "second user",
      "id": "2",
      "first": "2Igor",
      "lastname": "Danilovsdfsd",
      "age": "30",
      "country": "USA",
      "city": "California",
      "currency": "EUR",
      "avatar": "https://as1.ftcdn.net/v2/jpg/02/04/65/06/1000_F_204650616_TRYxpIwZnEg7Yu4CDDE790fQwsRbBlUU.jpg"
    }
  ]
}